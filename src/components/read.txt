



/**********************************************************************************************************************************************************************************/

axios
    .get(this.pokemon)
    .then(response => {
        this.pokemonList = [...this.pokemonList, ...response.data.results];
        this.nextUrl = response.data.next; 
        this.pokemonList.forEach(pokemon => {
            // Ottenere l'ID del Pokémon dall'URL
            const pokemonId = pokemon.url.split('/').filter(part => !!part).pop();
            
            // Costruire l'URL completo dell'immagine
            pokemon.image = `${this.imagePokemon}${pokemonId}.png`;
            
        });  
    })
    .catch(error => {
        console.error('Error Pokemon list:', error);
        
    });



1.  - axios.get(this.pokemon): Con questa istruzione, Axios esegue una richiesta GET all'URL specificato da this.pokemon. Presumibilmente, this.pokemon è un URL API che restituisce un elenco di Pokémon o informazioni su Pokémon.

2. - .then(response => { ... }): Quando la richiesta ha successo, il metodo then viene chiamato con la risposta della richiesta come argomento. Questo blocco di codice gestisce la risposta della richiesta.

3. - this.pokemonList = [...this.pokemonList, ...response.data.results];: Questa istruzione aggiunge i risultati della risposta alla lista pokemonList. Utilizza uno spread operator per combinare i risultati attuali con quelli appena ricevuti dalla risposta.

4. - this.nextUrl = response.data.next;: Se l'API fornisce un URL per caricare ulteriori risultati (ad esempio, per la paginazione), questo codice salva l'URL successivo nella variabile nextUrl. Questo può essere utilizzato in seguito per ottenere ulteriori dati.

5. - this.pokemonList.forEach(pokemon => { ... }): Questo ciclo forEach scorre attraverso ciascun oggetto Pokémon nell'array pokemonList e aggiunge un campo image all'oggetto. Utilizza l'ID del Pokémon estratto dall'URL per costruire un URL completo per l'immagine del Pokémon utilizzando this.imagePokemon.

6. - .catch(error => { ... }): Questo blocco di codice gestisce eventuali errori che si verificano durante la richiesta. In caso di errore, viene mostrato un messaggio di errore nella console.

In sintesi, questo blocco di codice effettua una richiesta GET all'URL specificato, gestisce la risposta aggiungendo i risultati alla lista pokemonList e costruisce gli URL delle immagini dei Pokémon. In caso di errore durante la richiesta, viene mostrato un messaggio di errore nella console.

/**********************************************************************************************************************************************************************************/



scrollTrigger() {
    const observer = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting && this.nextUrl) { 
            this.getPokemon(this.nextUrl); 
        }
    });

    observer.observe(document.querySelector('.scroll-trigger'));
},
next(){
    this.currentUrl = this.nextUrl;  
}


1. - scrollTrigger(): Questa funzione definisce un osservatore di intersezione (IntersectionObserver) che monitora l'elemento nella pagina con la classe CSS .scroll-trigger. L'osservatore di intersezione è una funzionalità del browser che consente di rilevare quando un elemento è visibile nell'area visualizzabile della finestra del browser. Quando l'elemento con la classe .scroll-trigger diventa visibile nell'area visualizzabile della finestra del browser (cioè quando il suo rettangolo di rendering interseca il rettangolo di rendering della finestra del browser), viene attivata una callback.

All'interno della callback, viene controllato se l'opzione isIntersecting dell'oggetto entries[0] è true (cioè se l'elemento è visibile) e se this.nextUrl è definito (cioè se c'è un URL successivo disponibile per caricare ulteriori dati). Se entrambe le condizioni sono soddisfatte, viene chiamato il metodo getPokemon(this.nextUrl) per caricare ulteriori Pokémon dall'URL successivo.

2. - next(): Questa funzione viene chiamata per impostare this.currentUrl su this.nextUrl. Questo può essere utilizzato per memorizzare l'URL successivo da utilizzare per le future richieste di caricamento dei Pokémon. Ad esempio, dopo aver caricato con successo un set di Pokémon dalla URL corrente, next() può essere chiamato per impostare l'URL corrente su quello successivo, in modo che il prossimo caricamento di Pokémon venga effettuato dall'URL successivo.

/**********************************************************************************************************************************************************************************/

const pokemonId = pokemon.url.split('/').filter(part => !!part).pop();


Ecco come funziona:

1. - pokemon.url: Questo rappresenta l'URL del Pokémon all'interno della risposta ottenuta dalla chiamata API. Ad esempio, potrebbe essere qualcosa come "https://pokeapi.co/api/v2/  pokemon/25/".

2. - .split('/'): Questo metodo divide l'URL utilizzando il carattere / come delimitatore, creando un array con ogni parte dell'URL come elemento. Ad esempio, ["https:", "", "pokeapi.co", "api", "v2", "pokemon", "25", ""].

3. - .filter(part => !!part): Questo filtra l'array per rimuovere eventuali elementi vuoti. Gli elementi vuoti possono verificarsi se ci sono due / consecutivi nell'URL, che creerebbe un elemento vuoto nell'array. L'operatore !!part converte l'elemento in un booleano (true se l'elemento non è vuoto, false altrimenti).

4. - .pop(): Questo estrae l'ultimo elemento dell'array, che è l'ID del Pokémon. Nel tuo esempio, l'ID del Pokémon è "25".